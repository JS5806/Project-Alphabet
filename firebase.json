rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // 유저 정보: 본인만 읽기/쓰기 가능
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // 식당 정보: 누구나 읽기 가능, 관리자만 쓰기 가능 (확장성 고려)
    match /restaurants/{restaurantId} {
      allow read: if true;
      allow write: if request.auth.token.admin == true;
    }

    // 투표 내역: 인증된 유저만 생성 가능, 수정/삭제 불가 (데이터 무결성)
    match /votes/{voteId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null 
                    && request.resource.data.userId == request.auth.uid
                    // 하루 1회 투표 제한 로직은 클라우드 함수 또는 트랜잭션에서 검증 권장
                    && request.resource.data.createdAt == request.time;
      allow update, delete: if false;
    }
  }
}
/**
 * RDBMS 전환 가능성을 고려하여 데이터 구조를 타입으로 엄격하게 정의
 */

// User Schema
export interface User {
  uid: string;
  email: string;
  displayName: string;
  lastVotedAt: Date | null; // 투표 어뷰징 방지용
  createdAt: Date;
}

// Restaurant Schema (NoSQL 최적화: voteCount를 포함하여 읽기 비용 절감)
export interface Restaurant {
  id: string;
  name: string;
  category: string;
  imageUrl?: string;
  voteCount: number; // 집계된 데이터 (실시간 업데이트)
  updatedAt: Date;
}

// Vote Schema (RDBMS의 Log 테이블 성격)
export interface Vote {
  id: string;
  userId: string;
  restaurantId: string;
  createdAt: Date; // Time-series 데이터 활용 가능
}
import { initializeApp } from "firebase/app";
import { getFirestore } from "firebase/firestore";
import { getAuth } from "firebase/auth";

const firebaseConfig = {
  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,
  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,
  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,
  storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,
  appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID
};

const app = initializeApp(firebaseConfig);
export const db = getFirestore(app);
export const auth = getAuth(app);
import { db } from "../lib/firebase/config";
import { doc, runTransaction, serverTimestamp } from "firebase/firestore";

/**
 * 트래픽 집중 시 데이터 동시성 문제를 해결하고 비용을 절감하기 위한 트랜잭션 처리
 * RDBMS 전환 시 이 레이어만 SQL Transaction으로 교체하면 됨 (Repository Pattern 적용)
 */
export const castVote = async (restaurantId: string, userId: string) => {
  const restaurantRef = doc(db, "restaurants", restaurantId);
  const voteRef = doc(db, "votes", `${userId}_${new Date().toISOString().split('T')[0]}`); // 복합키 시뮬레이션 (UserID_Date)
  const userRef = doc(db, "users", userId);

  try {
    await runTransaction(db, async (transaction) => {
      // 1. 중복 투표 체크 (읽기 비용 발생하지만 무결성 보장)
      const voteDoc = await transaction.get(voteRef);
      if (voteDoc.exists()) {
        throw new Error("User has already voted today.");
      }

      // 2. 식당 투표 수 증가 (NoSQL Denormalization: 읽기 비용 최적화)
      transaction.update(restaurantRef, {
        voteCount: increment(1), // Atomic increment
        updatedAt: serverTimestamp()
      });

      // 3. 투표 로그 생성
      transaction.set(voteRef, {
        restaurantId,
        userId,
        createdAt: serverTimestamp()
      });

      // 4. 유저 마지막 투표 시간 갱신
      transaction.update(userRef, {
        lastVotedAt: serverTimestamp()
      });
    });
    console.log("Vote transaction completed successfully.");
  } catch (e) {
    console.error("Vote transaction failed: ", e);
    throw e;
  }
};

// increment 헬퍼 임포트 필요 (firebase/firestore)
import { increment } from "firebase/firestore";
name: CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
          
      - name: Install Dependencies
        run: npm ci
        
      - name: Run Lint
        run: npm run lint
        
      - name: Build
        run: npm run build

      # 테스트 코드 실행 (예: Jest)
      # - name: Run Test
      #   run: npm test

  deploy-firebase:
    needs: build-and-test
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Install Dependencies & Build
        run: |
          npm ci
          npm run build
          
      - name: Deploy to Firebase Hosting
        uses: FirebaseExtended/action-hosting-deploy@v0
        with:
          repoToken: '${{ secrets.GITHUB_TOKEN }}'
          firebaseServiceAccount: '${{ secrets.FIREBASE_SERVICE_ACCOUNT }}'
          channelId: live
          projectId: your-project-id
# 향후 하이브리드 인프라 또는 백엔드 API 서버 컨테이너화 대비
# 빌드 단계
FROM node:18-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

# 실행 단계 (경량화)
FROM node:18-alpine AS runner
WORKDIR /app
ENV NODE_ENV production

COPY --from=builder /app/public ./public
COPY --from=builder /app/.next/standalone ./
COPY --from=builder /app/.next/static ./.next/static

EXPOSE 3000
CMD ["node", "server.js"]
{
  "firestore": {
    "rules": "firestore.rules",
    "indexes": "firestore.indexes.json"
  },
  "hosting": {
    "public": "out",
    "ignore": [
      "firebase.json",
      "**/.*",
      "**/node_modules/**"
    ],
    "rewrites": [
      {
        "source": "**",
        "destination": "/index.html"
      }
    ],
    "headers": [
      {
        "source": "**/*.@(jpg|jpeg|gif|png)",
        "headers": [
          {
            "key": "Cache-Control",
            "value": "max-age=7200"
          }
        ]
      }
    ]
  }
}