-- [Extensions]
-- HTTP ìš”ì²­ì„ ìœ„í•œ í™•ì¥ (Slack Webhookìš©)
create extension if not exists "pg_net" with schema "extensions";

-- [Tables]
-- 1. ì‹ë‹¹ ì •ë³´ í…Œì´ë¸”
create table public.restaurants (
    id bigint generated by default as identity primary key,
    name text not null,
    location text,
    created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- 2. ë©”ë‰´ ì •ë³´ í…Œì´ë¸” (íƒœê·¸ í¬í•¨)
create table public.menus (
    id bigint generated by default as identity primary key,
    restaurant_id bigint references public.restaurants(id) on delete cascade not null,
    name text not null,
    tags text[] default '{}', -- ì˜ˆ: ['í•œì‹', 'ë§¤ìš´ë§›']
    price integer,
    image_url text,
    created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- 3. íˆ¬í‘œ í…Œì´ë¸”
create table public.votes (
    id bigint generated by default as identity primary key,
    user_id uuid references auth.users(id) not null,
    menu_id bigint references public.menus(id) not null,
    voted_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- [Indexes & Constraints]
-- 1ì¼ 1íˆ¬í‘œ ì œí•œ (DB ë ˆë²¨ ê²€ì¦)
-- user_idì™€ íˆ¬í‘œ ë‚ ì§œ(YYYY-MM-DD)ë¥¼ ê²°í•©í•˜ì—¬ ìœ ë‹ˆí¬ ì¸ë±ìŠ¤ ìƒì„±
create unique index unique_daily_vote 
on public.votes (user_id, (voted_at::date));

-- [Row Level Security (RLS)]
-- RLS í™œì„±í™”
alter table public.restaurants enable row level security;
alter table public.menus enable row level security;
alter table public.votes enable row level security;

-- ì •ì±…: ëˆ„êµ¬ë‚˜ ì‹ë‹¹/ë©”ë‰´ ì¡°íšŒ ê°€ëŠ¥
create policy "Public restaurants are viewable by everyone" 
on public.restaurants for select using (true);

create policy "Public menus are viewable by everyone" 
on public.menus for select using (true);

-- ì •ì±…: ì¸ì¦ëœ ì‚¬ìš©ìë§Œ ì‹ë‹¹/ë©”ë‰´ ë“±ë¡ (ê´€ë¦¬ì ë¡œì§ì´ í•„ìš”í•˜ë‹¤ë©´ using ì¡°ê±´ ìˆ˜ì • í•„ìš”)
create policy "Authenticated users can insert menus" 
on public.menus for insert with check (auth.role() = 'authenticated');

-- ì •ì±…: íˆ¬í‘œëŠ” ë³¸ì¸ë§Œ ìƒì„±/ì‚­ì œ ê°€ëŠ¥, ì¡°íšŒëŠ” ëˆ„êµ¬ë‚˜(ì‹¤ì‹œê°„ ì§‘ê³„ìš©)
create policy "Users can vote" 
on public.votes for insert with check (auth.uid() = user_id);

create policy "Users can delete own vote" 
on public.votes for delete using (auth.uid() = user_id);

create policy "Public votes are viewable" 
on public.votes for select using (true);

-- [Functions & Triggers]

-- 1. ì´ë©”ì¼ ë„ë©”ì¸ ê²€ì¦ í•¨ìˆ˜ (Auth Hook)
-- auth.users í…Œì´ë¸”ì— insert ë°œìƒ ì‹œ íŠ¸ë¦¬ê±°ë¨
create or replace function public.validate_company_email()
returns trigger as $$
begin
  -- ì‚¬ë‚´ ë„ë©”ì¸(@company.com)ì´ ì•„ë‹ˆë©´ ì—ëŸ¬ ë°œìƒ
  if new.email not like '%@company.com' then
    raise exception 'ì‚¬ë‚´ ì´ë©”ì¼(@company.com)ë§Œ ê°€ì… ê°€ëŠ¥í•©ë‹ˆë‹¤.';
  end if;
  return new;
end;
$$ language plpgsql security definer;

-- íŠ¸ë¦¬ê±° ì—°ê²°
create trigger check_email_domain
  before insert on auth.users
  for each row execute function public.validate_company_email();

-- 2. íˆ¬í‘œ ê²°ê³¼ ì‚°ì¶œ ë° ì•Œë¦¼ ì „ì†¡ í•¨ìˆ˜
-- Edge Functions ë˜ëŠ” pg_cronì—ì„œ í˜¸ì¶œë  ë©”ì¸ ë¡œì§
create or replace function public.calculate_result_and_notify()
returns json as $$
declare
    target_date date := current_date;
    winning_menu_id bigint;
    winning_menu_name text;
    vote_count bigint;
    slack_webhook_url text := 'https://hooks.slack.com/services/YOUR/WEBHOOK/URL'; -- ì‹¤ì œ URLë¡œ êµì²´ ë˜ëŠ” Vault ì‚¬ìš©
    payload jsonb;
    request_id bigint;
begin
    -- A. ìµœë‹¤ ë“í‘œ ë©”ë‰´ ì„ ì • (ë™ì ì ëœë¤ í”½ ë¡œì§ í¬í•¨)
    with vote_counts as (
        select menu_id, count(*) as cnt
        from public.votes
        where voted_at::date = target_date
        group by menu_id
    ),
    max_votes as (
        select max(cnt) as max_cnt from vote_counts
    ),
    candidates as (
        select vc.menu_id, vc.cnt
        from vote_counts vc
        join max_votes mv on vc.cnt = mv.max_cnt
    )
    select c.menu_id, c.cnt, m.name
    into winning_menu_id, vote_count, winning_menu_name
    from candidates c
    join public.menus m on c.menu_id = m.id
    order by random() -- ë™ì ì ì¤‘ ëœë¤ ì„ íƒ
    limit 1;

    -- íˆ¬í‘œê°€ ì—†ëŠ” ê²½ìš° ì²˜ë¦¬
    if winning_menu_id is null then
        return json_build_object('status', 'no_votes');
    end if;

    -- B. Slack ì•Œë¦¼ ì „ì†¡ (pg_net í™•ì¥ ì‚¬ìš©)
    payload := jsonb_build_object(
        'text', format('ì˜¤ëŠ˜ì˜ ì ì‹¬ ë©”ë‰´ ì„ ì • ê²°ê³¼! ğŸ±%në©”ë‰´: *%s*%në“í‘œìˆ˜: %sí‘œ', winning_menu_name, vote_count)
    );

    -- ë¹„ë™ê¸° HTTP POST ìš”ì²­
    select "net".http_post(
        url := slack_webhook_url,
        body := payload,
        headers := '{"Content-Type": "application/json"}'::jsonb
    ) into request_id;

    return json_build_object(
        'status', 'success',
        'menu', winning_menu_name,
        'votes', vote_count,
        'request_id', request_id
    );
end;
$$ language plpgsql security definer;

-- [Realtime]
-- í´ë¼ì´ì–¸íŠ¸ì—ì„œ ì‹¤ì‹œê°„ ë“í‘œ í˜„í™©ì„ êµ¬ë…í•˜ê¸° ìœ„í•´ Realtime publicationì— í…Œì´ë¸” ì¶”ê°€
-- Supabase ëŒ€ì‹œë³´ë“œì—ì„œ Replication ì„¤ì •ì´ í•„ìš”í•  ìˆ˜ ìˆìŒ
alter publication supabase_realtime add table public.votes;
