{
  "name": "lunch-vote-backend",
  "description": "Serverless backend for lunch voting system",
  "engines": {
    "node": "18"
  },
  "main": "index.js",
  "dependencies": {
    "firebase-admin": "^11.10.1",
    "firebase-functions": "^4.4.1",
    "express": "^4.18.2",
    "cors": "^2.8.5",
    "axios": "^1.4.0",
    "moment": "^2.29.4"
  },
  "private": true
}
const axios = require('axios');
const functions = require('firebase-functions');

// Slack Webhook URL í™˜ê²½ë³€ìˆ˜ ì„¤ì • í•„ìš” (firebase functions:config:set slack.webhook="URL")
const SLACK_WEBHOOK_URL = functions.config().slack?.webhook;

/**
 * ìŠ¬ë™ ì•Œë¦¼ ë°œì†¡ (Rate Limit ì²˜ë¦¬ë¥¼ ìœ„í•œ ì¬ì‹œë„ ë¡œì§ í¬í•¨)
 * @param {string} text - ë°œì†¡í•  ë©”ì‹œì§€
 * @param {number} retryCount - ì¬ì‹œë„ íšŸìˆ˜
 */
exports.sendSlackNotification = async (text, retryCount = 0) => {
  if (!SLACK_WEBHOOK_URL) {
    console.error("Slack Webhook URL is missing.");
    return;
  }

  try {
    await axios.post(SLACK_WEBHOOK_URL, { text });
    console.log("Slack notification sent successfully.");
  } catch (error) {
    if (error.response && error.response.status === 429 && retryCount < 3) {
      // API Rate Limit (429) ë°œìƒ ì‹œ ì§€ìˆ˜ ë°±ì˜¤í”„ ì ìš© í›„ ì¬ì‹œë„
      const delay = Math.pow(2, retryCount) * 1000;
      console.warn(`Rate limit hit. Retrying in ${delay}ms...`);
      await new Promise(resolve => setTimeout(resolve, delay));
      return exports.sendSlackNotification(text, retryCount + 1);
    }
    console.error("Failed to send Slack notification:", error.message);
  }
};
const admin = require('firebase-admin');
const db = admin.firestore();

// ì‹ë‹¹ ë“±ë¡
exports.createRestaurant = async (req, res) => {
  try {
    const { name, location, menu } = req.body;
    const docRef = await db.collection('restaurants').add({
      name,
      location,
      menu,
      createdAt: admin.firestore.FieldValue.serverTimestamp()
    });
    res.status(201).json({ id: docRef.id, message: 'Restaurant added' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

// ì‹ë‹¹ ì¡°íšŒ (ì „ì²´)
exports.getRestaurants = async (req, res) => {
  try {
    const snapshot = await db.collection('restaurants').get();
    const restaurants = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    res.status(200).json(restaurants);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

// ì‹ë‹¹ ìˆ˜ì •
exports.updateRestaurant = async (req, res) => {
  try {
    const { id } = req.params;
    await db.collection('restaurants').doc(id).update(req.body);
    res.status(200).json({ message: 'Restaurant updated' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

// ì‹ë‹¹ ì‚­ì œ
exports.deleteRestaurant = async (req, res) => {
  try {
    const { id } = req.params;
    await db.collection('restaurants').doc(id).delete();
    res.status(200).json({ message: 'Restaurant deleted' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};
const admin = require('firebase-admin');
const db = admin.firestore();
const { sendSlackNotification } = require('../utils/slackClient');

// íˆ¬í‘œ í–‰ì‚¬ (íŠ¸ëœì­ì…˜ì„ ì´ìš©í•œ ì¤‘ë³µ ë°©ì§€)
exports.castVote = async (req, res) => {
  const { sessionId, restaurantId, userId } = req.body;
  const sessionRef = db.collection('voteSessions').doc(sessionId);

  try {
    await db.runTransaction(async (t) => {
      const sessionDoc = await t.get(sessionRef);
      if (!sessionDoc.exists) throw new Error("Session does not exist");
      
      const data = sessionDoc.data();
      if (data.status !== 'open') throw new Error("Voting session is closed");
      
      const votedUsers = data.votedUsers || [];
      if (votedUsers.includes(userId)) throw new Error("User already voted");

      // ë“í‘œìˆ˜ ì—…ë°ì´íŠ¸ ë° ì‚¬ìš©ì ê¸°ë¡
      const currentVotes = data.votes || {};
      const newCount = (currentVotes[restaurantId] || 0) + 1;
      
      t.update(sessionRef, {
        [`votes.${restaurantId}`]: newCount,
        votedUsers: admin.firestore.FieldValue.arrayUnion(userId)
      });
    });

    res.status(200).json({ message: 'Vote cast successfully' });
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
};

// íˆ¬í‘œ ì¢…ë£Œ ë° ê²°ê³¼ ì„ ì • (ëœë¤ ì•Œê³ ë¦¬ì¦˜ í¬í•¨)
exports.closeSession = async (req, res) => {
  const { sessionId } = req.body;
  const sessionRef = db.collection('voteSessions').doc(sessionId);

  try {
    const result = await db.runTransaction(async (t) => {
      const doc = await t.get(sessionRef);
      if (!doc.exists) throw new Error("Session not found");
      
      const data = doc.data();
      const votes = data.votes || {};
      
      // ìµœë‹¤ ë“í‘œ ì°¾ê¸°
      let maxVote = -1;
      let candidates = [];
      
      for (const [restId, count] of Object.entries(votes)) {
        if (count > maxVote) {
          maxVote = count;
          candidates = [restId];
        } else if (count === maxVote) {
          candidates.push(restId);
        }
      }

      // ë“í‘œê°€ ì—†ê±°ë‚˜ ë™ë¥ ì¼ ê²½ìš° ì „ì²´/í›„ë³´êµ° ë‚´ ëœë¤ ì„ ì •
      let selectedId;
      if (candidates.length === 0) {
         // íˆ¬í‘œê°€ ì—†ìœ¼ë©´ ë“±ë¡ëœ ì‹ë‹¹ ì¤‘ ëœë¤ ì¶”ì²œ
         const allRestSnapshot = await db.collection('restaurants').get();
         if (allRestSnapshot.empty) throw new Error("No restaurants available");
         const randomIdx = Math.floor(Math.random() * allRestSnapshot.size);
         selectedId = allRestSnapshot.docs[randomIdx].id;
      } else {
         // í›„ë³´êµ°(ë™ë¥  í¬í•¨) ì¤‘ ëœë¤ ì„ ì •
         const randomIdx = Math.floor(Math.random() * candidates.length);
         selectedId = candidates[randomIdx];
      }

      // ì‹ë‹¹ ìƒì„¸ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
      const restDoc = await t.get(db.collection('restaurants').doc(selectedId));
      const restData = restDoc.data();

      t.update(sessionRef, {
        status: 'closed',
        result: { id: selectedId, name: restData.name }
      });

      return { id: selectedId, name: restData.name, voteCount: maxVote };
    });

    // ìŠ¬ë™ ì•Œë¦¼ ë¹„ë™ê¸° íŠ¸ë¦¬ê±°
    await sendSlackNotification(`ğŸ“¢ íˆ¬í‘œ ì¢…ë£Œ! ì˜¤ëŠ˜ì˜ ì ì‹¬ ì¥ì†ŒëŠ” *${result.name}* ì…ë‹ˆë‹¤.`);

    res.status(200).json({ message: 'Session closed', result });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const express = require('express');
const cors = require('cors');

admin.initializeApp();

const restaurantController = require('./controllers/restaurantController');
const voteController = require('./controllers/voteController');
const { sendSlackNotification } = require('./utils/slackClient');

const app = express();
app.use(cors({ origin: true }));
app.use(express.json());

// --- Routes: Restaurants (CRUD) ---
app.post('/restaurants', restaurantController.createRestaurant);
app.get('/restaurants', restaurantController.getRestaurants);
app.put('/restaurants/:id', restaurantController.updateRestaurant);
app.delete('/restaurants/:id', restaurantController.deleteRestaurant);

// --- Routes: Voting ---
app.post('/vote', voteController.castVote);
app.post('/vote/close', voteController.closeSession);

// Expose Express API as a single Cloud Function
exports.api = functions.https.onRequest(app);

// --- Firestore Triggers ---

// íˆ¬í‘œ ì„¸ì…˜ ìƒì„± ì‹œ ìŠ¬ë™ ì•Œë¦¼ (íˆ¬í‘œ ì‹œì‘)
exports.onVoteSessionCreated = functions.firestore
  .document('voteSessions/{sessionId}')
  .onCreate(async (snap, context) => {
    const data = snap.data();
    await sendSlackNotification(`ğŸ”” ìƒˆë¡œìš´ ì ì‹¬ íˆ¬í‘œê°€ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤! (${data.title || 'ì˜¤ëŠ˜ì˜ ì ì‹¬'})`);
  });

// íˆ¬í‘œ ê²°ê³¼ í™•ì • ì‹œ ì¶”ê°€ ë¡œì§ (í•„ìš” ì‹œ í™•ì¥ ê°€ëŠ¥)
exports.onVoteSessionUpdated = functions.firestore
  .document('voteSessions/{sessionId}')
  .onUpdate(async (change, context) => {
    const newData = change.after.data();
    const previousData = change.before.data();

    // ìƒíƒœê°€ open -> closedë¡œ ë³€ê²½ë˜ì—ˆì„ ë•Œë§Œ íŠ¸ë¦¬ê±°
    if (previousData.status === 'open' && newData.status === 'closed') {
        console.log(`Vote Closed. Result: ${newData.result?.name}`);
        // Note: Controllerì—ì„œ ì•Œë¦¼ì„ ë³´ë‚´ì§€ë§Œ, ì´ê³³ì—ì„œ ë³´ì¥ì„± ì•Œë¦¼ì„ ë³´ë‚¼ ìˆ˜ë„ ìˆìŒ.
    }
  });
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // ì‹ë‹¹ ì •ë³´: ëˆ„êµ¬ë‚˜ ì½ê¸° ê°€ëŠ¥, ì“°ê¸°ëŠ” ì¸ì¦ëœ ê´€ë¦¬ì(ì˜ˆì‹œ)ë§Œ ê°€ëŠ¥
    match /restaurants/{restaurant} {
      allow read: if true;
      allow write: if request.auth != null; 
    }
    
    // íˆ¬í‘œ ì„¸ì…˜: ëˆ„êµ¬ë‚˜ ì½ê¸° ê°€ëŠ¥
    match /voteSessions/{session} {
      allow read: if true;
      // ì“°ê¸°(íˆ¬í‘œ, ì¢…ë£Œ ë“±)ëŠ” Cloud Functions(Backend Admin SDK)ë¥¼ í†µí•´ì„œë§Œ ì²˜ë¦¬í•˜ë„ë¡ ì œí•œí•˜ì—¬ ì •í•©ì„± ìœ ì§€
      allow write: if false; 
    }
  }
}